


```{r}
#diversify 
#sd-of-cellstate-per-donor_mean_nounknown
sd_mean_nounknown <- lapply(prob_all_nounknown, function(x) { # per tool
  x <- apply(x,1,FUN = sd) # sd of cellstate per donor
  x <- mean(x) # mean of sd
  return(x)
})

```

```{r}
# library(renv)
# renv::init()
# BiocManager::install()
```

```{r}
library(dplyr)
library(here)
library(tidyr)
library(tibble)
library(easyCODA)
#library(zCompositions) it will interfere with dplyr select function
library(topsis)
```


```{r}
#Set working directory
setwd(here())
source("script/function.R")
```
```{r}

# Parameter
# cell input to be analyse

object <- "all"

sigs <- c( "4metamodules_new_50_mes","2metamodules_NPC_OPC", "3metamodules_new_50", "4metamodules_new_50","npcopc_ac_mes","npcopc_acmes")



# For reference based
merges <- c("4_merge_metamodules_mes","2_merge_metamodules",  "4_merge_metamodules_3celltypes","4_merge_metamodules","npcopc_ac_mes","npcopc_acmes")


unknowns <- c("","_no_unknown")


run_eachs <- c(TRUE,FALSE)
runs <- c("each","whole")


possible_3celltpyes <- c("AClike","NPClike","OPClike","unknown","tie")
possible_cellstate <- c("AClike","NPClike","OPClike","MESlike","unknown","tie")

```
```{r}
#set unknown 
unknown <- unknowns[1]

#set whole vs each
run_each <- run_eachs[1]

#3 celltype

pick <- 4

sig <- sigs[pick]
merge <- merges[pick]


#run_each <- run_eachs[2]
if (run_each) {
  run <- runs[1]
} else {
  run <- runs[2]
}

```

```{r}
gbm.meta <- read.csv("output/gbm_meta.csv",row.names = 1)
gbm.meta
```

```{r}
# import all data
# marker.based
sc.type <- read.csv(paste0("output/scType_", object, "_", sig,"_",run, ".csv"), row.names = 1)
sc.type <- sc.type[,paste0("scType",unknown) ,drop = FALSE]

scina <- read.csv(paste0("output/SCINA_", object, "_", sig,"_",run, ".csv"), row.names = 1)
scina <- scina[,paste0("SCINA",unknown) ,drop = FALSE]


# add full option
sc.sorter <- read.csv(paste0("output/scsorter_", object, "_", sig, "_",run,".csv"), row.names = 1)
sc.sorter$scSorter_no_unknown <- NA
sc.sorter <- sc.sorter[,paste0("scSorter",unknown) ,drop = FALSE]
```


```{r}
#unknown <- unknowns[1]
# ref-based
clustify.r <- read.csv(paste0("output/clustifyr_", object, "_", merge, "_",run,".csv"), row.names = 1)
#clustify.r <- clustify.r[,paste0("clustifyr_ref",unknown) ,drop = FALSE]
clustify.r <- clustify.r[,paste0("clustifyr_ref") ,drop = FALSE]

scid <- read.csv(paste0("output/scID_", object, "_", merge,"_allassigned","_",run,".csv"), row.names = 1)
scid <- scid[,paste0("scID",unknown) ,drop = FALSE]


```


```{r}
#Add Full option
sc.pred <- read.csv(paste0("output/scpred_", object, "_", merge, "_",run, ".csv"), row.names = 1)
sc.pred <- sc.pred[,2:1]
colnames(sc.pred) <- c("scPred",paste0("scPred",unknowns[2]))
sc.pred <- sc.pred[,paste0("scPred",unknown) ,drop = FALSE]

single.r <- read.csv(paste0("output/singleR_", object, "_", merge, "_",run, ".csv"), row.names = 1)
single.r <- single.r[,2:1]
colnames(single.r) <- c("singleR",paste0("singleR",unknowns[2]))
single.r[is.na(single.r$singleR),"singleR"] <- "unknown"
single.r <- single.r[,paste0("singleR",unknown) ,drop = FALSE]

scibet <- read.csv(paste0("output/scibet_", object, "_", merge,  "_",run,".csv"), row.names = 1)
scibet$scibet_no_unknown <- scibet$scibet #no unknown by default
scibet <- scibet[,paste0("scibet",unknown) ,drop = FALSE]

chetah <- read.csv(paste0("output/CHETAH_", object, "_", merge, "_",run, ".csv"), row.names = 1)
chetah$CHETAH_no_unknown <- chetah$CHETAH
chetah <- chetah[,paste0("CHETAH",unknown) ,drop = FALSE]

scmap_cluster <- read.csv(paste0("output/scmap_cluster_", object, "_", merge,  "_",run,".csv"), row.names = 1)
scmap_cluster$scmap_cluster_no_unknown <- scmap_cluster$scmap_cluster #cannot tweak to have no unknown
scmap_cluster <- scmap_cluster[,paste0("scmap_cluster",unknown) ,drop = FALSE]

scmap_cell <- read.csv(paste0("output/scmap_cell_", object, "_", merge,  "_",run,".csv"), row.names = 1)
scmap_cell$scmap_cell_no_unknown <- scmap_cell$scmap_cell #cannot tweak to have no unknown
scmap_cell <- scmap_cell[,paste0("scmap_cell",unknown) ,drop = FALSE]
```

```{r}
#sc.type;scina; clustify.r;scid;sc.sorter;sc.pred;scibet;chetah;single.r;scmap_cluster;scmap_cluster
```


```{r}
anno_cellstate <- bind_cols(sc.type, scina, clustify.r,scid)

#full option
anno_cellstate <- bind_cols(sc.type, scina, sc.sorter,clustify.r,scid,sc.pred,scibet,chetah,single.r,scmap_cluster,scmap_cell)

#colnames(anno_cellstate) <- paste(colnames(anno_cellstate), sig, sep = "_")
anno_cellstate[] <- lapply(anno_cellstate, function(x) gsub("NPC_OPC$", "NPC_OPClike", x))
anno_cellstate[] <- lapply(anno_cellstate, function(x) gsub("AC$", "AClike", x))
anno_cellstate[] <- lapply(anno_cellstate, function(x) gsub("MES$", "MESlike", x))
anno_cellstate[] <- lapply(anno_cellstate, function(x) gsub("AC_MES$", "AC_MESlike", x))
anno_cellstate[] <- lapply(anno_cellstate, function(x) gsub("\\.new$", "like", x))
anno_cellstate[] <- lapply(anno_cellstate, function(x) gsub("Unknown", "unknown", x))
anno_cellstate[] <- lapply(anno_cellstate, function(x) gsub("unassigned", "unknown", x))

```

```{r}
anno_cellstate_meta <- cbind(gbm.meta[,c("donor_radiation","donor_id","radiation")],anno_cellstate)
anno_cellstate_meta$donor_radiation <- as.factor(anno_cellstate_meta$donor_radiation)

anno_cellstate_meta
```

```{r}
# Do sankey
library(ggsankey)
library(ggplot2)
library(patchwork)
library(ggtext)




my_colors <- c("red", "green", "blue", "gray", "purple", "orange")
plots_list <- list()

for (i in levels(anno_cellstate_meta$donor_radiation)) {
  anno_cellstate_meta_each <- anno_cellstate_meta[anno_cellstate_meta$donor_radiation == i,]
  anno_cellstate_meta_each <- anno_cellstate_meta_each %>% select(-1:-3)
  all.sankey <- anno_cellstate_meta_each
  colnames(all.sankey) <- gsub("_no_unknown","",colnames(all.sankey))
  df <- all.sankey %>%
    make_long(colnames(all.sankey))

  # Chart 1
  pl <- ggplot(df, aes(
    x = x,
    next_x = next_x,
    node = node,
    next_node = next_node,
    fill = factor(node),
    label = node
  ))
  pl <- pl + geom_sankey(
    flow.alpha = 0.5,
    node.color = "black",
    show.legend = FALSE
  )
  #pl <- pl + geom_sankey_label(size = 2, color = "black", fill = "white")
  pl <- pl + theme_bw()
  pl <- pl + theme(legend.position = "none")
  pl <- pl + theme(
    axis.title = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    axis.text.x = element_blank(),
    panel.grid = element_blank()
  )

  pl <- pl + labs(subtitle = paste(i,"; ",
                                   round(nrow(anno_cellstate_meta_each)*100/nrow(anno_cellstate_meta),digits = 2),"%",
                                   sep = ""))
  pl <- pl + labs(fill = "Nodes")
  pl <- pl + scale_fill_manual(values = my_colors)
  plots_list[[i]] <- pl
}

combined_plot <- wrap_plots(plots_list, ncol = 6)


# Assuming 'my_colors' is your color vector and 'df' is your data frame
# Map colors to factor levels
color_mapping <- setNames(my_colors, levels(factor(df$node)))

# Construct the caption string dynamically
caption_text <- paste(sapply(names(color_mapping), function(node) {
  sprintf("<span style='color: %s;'>%s</span>", color_mapping[node], node)
}), collapse = " ")

combined_plot + plot_annotation(
    title = paste0(paste(setdiff(levels(factor(df$node)),"unknown"),collapse = ", ") ," cell states","; ",unknown,"; ",run),
    subtitle = caption_text,
    caption = paste(colnames(anno_cellstate),collapse = "; "),
    theme = theme(plot.subtitle = element_markdown())
)
```

#Choose tools: start from 10/ Jan/ 24
```{r}
anno_cellstate_meta_control <- anno_cellstate_meta[,-1] %>%
  filter(radiation == "control") %>%
  select(!c(radiation))
unique_tool <- unique(
  unlist(
  anno_cellstate_meta_control[,!colnames(anno_cellstate_meta_control) %in% "donor_id"]
  )
  )
unique_donor_id <- unique(anno_cellstate_meta_control$donor_id)

unique_tool_donor_id <- length(unique_tool)*length(unique_donor_id)

count_all_list <- list()
prob_all_list <- list()
count_all <- data.frame(matrix(nrow = unique_tool_donor_id, ncol = 0))
prob_all <- data.frame(matrix(nrow = unique_tool_donor_id, ncol = 0))
for (i in 2:ncol(anno_cellstate_meta_control)) {
  anno_cellstate_meta_eachtool <- anno_cellstate_meta_control[,c(1,i)] 
  # anno_cellstate_meta_eachtool <- anno_cellstate_meta_control[,c("donor_id","scSorter")] 
  
  # anno_cellstate_meta_eachtool[,2] <- factor(anno_cellstate_meta_eachtool[,2],levels = possible_cellstate[1:5]) 
  anno_cellstate_meta_eachtool[,2] <- factor(anno_cellstate_meta_eachtool[,2],levels = unique_tool) 

  count_tool_alldonor <- data.frame()
  prob_tool_alldonor <- data.frame()
  for (q in unique(anno_cellstate_meta_eachtool$donor_id)) {
    anno_cellstate_meta_eachtool_eachdonor <- anno_cellstate_meta_eachtool[anno_cellstate_meta_eachtool$donor_id == q,]
    count_tool <- as.data.frame(table(anno_cellstate_meta_eachtool_eachdonor[,2]))
    #count_tool[,2] <- count_tool[,2]/nrow(anno_cellstate_meta_eachtool_eachdonor)
    
    
    tool_name <- colnames(anno_cellstate_meta_eachtool_eachdonor)[2]
    colnames(count_tool) <- c("cellstate",tool_name)
    count_tool$donor_id <- rep(q,times = nrow(count_tool))
    count_tool_alldonor <- rbind(count_tool_alldonor,count_tool)
    count_tool_alldonor <- count_tool_alldonor %>% arrange(donor_id,cellstate)
    
    prob_tool <- count_tool
    prob_tool[,2] <- prob_tool[,2]/nrow(anno_cellstate_meta_eachtool_eachdonor)
    prob_tool_alldonor <- rbind(prob_tool_alldonor,prob_tool)
    prob_tool_alldonor <- prob_tool_alldonor %>% arrange(donor_id,cellstate)
    
    count_tool_alldonor_wide <- spread(count_tool_alldonor, donor_id, tool_name)
    count_tool_alldonor_wide <- column_to_rownames(count_tool_alldonor_wide,var = "cellstate")
    count_tool_alldonor_wide <- data.frame(t(count_tool_alldonor_wide))
    count_all_list[[tool_name]] <- count_tool_alldonor_wide
    
    prob_tool_alldonor_wide <- spread(prob_tool_alldonor, donor_id, tool_name)
    prob_tool_alldonor_wide <- column_to_rownames(prob_tool_alldonor_wide,var = "cellstate")
    prob_tool_alldonor_wide <- data.frame(t(prob_tool_alldonor_wide))
    prob_all_list[[tool_name]] <- prob_tool_alldonor_wide
    
    
  }
  count_all <- cbind(count_all,count_tool_alldonor[,2,drop = FALSE])
  prob_all <- cbind(prob_all,prob_tool_alldonor[,2,drop = FALSE])
}

count_all <- cbind(count_tool_alldonor[,c(1,3)],count_all)
prob_all <- cbind(prob_tool_alldonor[,c(1,3)],prob_all)
```





```{r}
#unknown proportion

prob_all_unknown_list <- lapply(count_all_list,function(x){
  (x$unknown)/rowSums(x)
})
prob_all_unknown_df <- as.data.frame(prob_all_unknown_list)


prob_all_unknown_mean <- apply(prob_all_unknown_df,2,mean)
prob_all_unknown_median <- apply(prob_all_unknown_df,2,median)

prob_all_unknown_mean_weighted <- lapply(count_all_list,function(x){
  (sum(x$unknown))/sum(x)
})



```

```{r}
#exclude unknown

count_all_nounknown_list <- lapply(count_all_list,function(x){
  x <- x %>% select(-unknown)
})

prob_all_nounknown <- lapply(count_all_nounknown_list,function(x){
  x <- x/rowSums(x) 
})

```

```{r}
impute_fn <- function(y) {
  lapply(y, function(x){
  if (any(x == 0)) {
    return(zCompositions::cmultRepl(x,z.warning = 1.01,method = "CZM",output = "p-counts"))
  } else {
    return(x)
  }
})
} 

```
```{r}
#check zero pattern
lapply(count_all_list,function(x){
  if (any(x == 0)) {
    return(zCompositions::zPatterns(x,label = 0))
  } else {
    return(x)
  }
  
})
```
```{r}
cmultRepl_edited <- function (X, label = 0, method = c("GBM", "SQ", "BL", "CZM", 
    "user"), output = c("prop", "p-counts"), frac = 0.65, threshold = 0.5, 
    adjust = TRUE, t = NULL, s = NULL, z.warning = 0.8, z.delete = TRUE, 
    suppress.print = FALSE, delta = NULL) 
{
    if (any(X < 0, na.rm = T)) 
        stop("X contains negative values")
    if (is.vector(X) | is.character(X) | (nrow(X) == 1)) 
        stop("X must be a data matrix")
    if (!is.na(label)) {
        if (!any(X == label, na.rm = T)) 
            stop(paste("Label", label, "was not found in the data set"))
        if (label != 0 & any(X == 0, na.rm = T)) 
            stop("Zero values not labelled as count zeros were found in the data set")
        if (any(is.na(X))) 
            stop(paste("NA values not labelled as count zeros were found in the data set"))
    }
    if (is.na(label)) {
        if (any(X == 0, na.rm = T)) 
            stop("Zero values not labelled as count zeros were found in the data set")
        if (!any(is.na(X), na.rm = T)) 
            stop(paste("Label", label, "was not found in the data set"))
    }
    if (!missing("delta")) {
        warning("The delta argument is deprecated, use frac instead: frac has been set equal to delta.")
        frac <- delta
    }
    X <- as.data.frame(X, stringsAsFactors = TRUE)
    X[X == label] <- NA
    checkNumZerosCol <- apply(X, 2, function(x) sum(is.na(x)))
    if (any(checkNumZerosCol/nrow(X) >= z.warning)) {
        cases <- which(checkNumZerosCol/nrow(X) >= z.warning)
        if (z.delete == TRUE) {
            if (length(cases) > (ncol(X) - 2)) {
                stop(paste("More than 2 columns contain >", z.warning * 
                  100, "% zeros/unobserved values (see arguments z.warning and z.delete).", 
                  sep = ""))
            }
            X <- X[, -cases]
            action <- "deleted"
            warning(paste("Column no. ", cases, " containing >", 
                z.warning * 100, "% zeros/unobserved values ", 
                action, " (see arguments z.warning and z.delete).\n", 
                sep = ""))
        }
        else {
            action <- "found"
            stop(paste("Column no. ", cases, " containing >", 
                z.warning * 100, "% zeros/unobserved values ", 
                action, " (see arguments z.warning and z.delete. Check out with zPatterns()).\n", 
                sep = ""))
        }
    }
    checkNumZerosRow <- apply(X, 1, function(x) sum(is.na(x)))
    if (any(checkNumZerosRow/ncol(X) >= z.warning)) {
        cases <- which(checkNumZerosRow/ncol(X) >= z.warning)
        if (z.delete == TRUE) {
            if (length(cases) > (nrow(X) - 2)) {
                stop(paste("More than 2 rows contain >", z.warning * 
                  100, "% zeros/unobserved values (see arguments z.warning and z.delete).", 
                  sep = ""))
            }
            X <- X[, -cases]
            action <- "deleted"
            warning(paste("Column no. ", cases, " containing >", 
                z.warning * 100, "% zeros/unobserved values ", 
                action, " (see arguments z.warning and z.delete).\n", 
                sep = ""))
        }
        else {
            action <- "found"
            stop(paste("Column no. ", cases, " containing >", 
                z.warning * 100, "% zeros/unobserved values ", 
                action, " (see arguments z.warning and z.delete. Check out with zPatterns()).\n", 
                sep = ""))
        }
    }
    N <- nrow(X)
    D <- ncol(X)
    n <- apply(X, 1, sum, na.rm = TRUE)
    method <- match.arg(method)
    output <- match.arg(output)
    if (method != "CZM") {
        if (method == "user") {
            t <- t
        }
        else {
            alpha <- matrix(0, nrow = N, ncol = D)
            for (i in 1:N) {
                alpha[i, ] <- apply(X, 2, function(x) sum(x[-i], 
                  na.rm = T))
            }
            t <- alpha/rowSums(alpha)
            if ((method == "GBM") && (any(t == 0))) {
                stop("GBM method: not enough information to compute t hyper-parameter,\n                                                probably there are columns with < 2 positive values.")
            }
        }
        s <- switch(method, GBM = 1/apply(t, 1, function(x) exp(mean(log(x)))), 
            SQ = sqrt(n), BL = D, user = s)
        repl <- t * (s/(n + s))
    }
    if (method == "CZM") {
        repl <- frac * matrix(1, ncol = D, nrow = N) * (threshold/n)
    }
    X2 <- t(apply(X, 1, function(x) x/sum(x, na.rm = T)))
    colmins <- apply(X2, 2, function(x) min(x, na.rm = T))
    adjusted <- 0
    for (i in 1:N) {
        if (any(is.na(X2[i, ]))) {
            z <- which(is.na(X2[i, ]))
            X2[i, z] <- repl[i, z]
            if (adjust == TRUE) {
                if (any(X2[i, z] > colmins[z])) {
                  f <- which(X2[i, z] > colmins[z])
                  X2[i, z][f] <- frac * colmins[z][f]
                  adjusted <- adjusted + length(f)
                }
            }
            X2[i, -z] <- (1 - (sum(X2[i, z]))) * X2[i, -z]
        }
    }
    if (output == "p-counts") {
        for (i in 1:N) {
            if (any(is.na(X[i, ]))) {
                zero <- which(is.na(X[i, ]))
                pos <- setdiff(1:D, zero)[1]
                X[i, zero] <- (X[i, pos]/X2[i, pos]) * X2[i, 
                  zero]
            }
        }
        res <- X
    }
    else {
        res <- X2
    }
    if (suppress.print == FALSE) {
        if ((adjust == TRUE) & (adjusted > 0)) {
            cat(paste("No. adjusted imputations: ", adjusted, 
                "\n"))
        }
    }
    return(as.data.frame(res, stringsAsFactors = TRUE))
}


```

```{r}
#calculate log variance
count_all_list_imputed <- impute_fn(count_all_list)
#prob_all_list_imputed <- impute_fn(prob_all_list)
```


```{r}
count_all_list
```


```{r}
count_all_list_imputed
```


```{r}
n <- 0
for (i in 1:length(count_all_list)){
  x <- count_all_list[[i]]
  if (any(x == 0)) {
    test <- (zCompositions::cmultRepl(x,z.warning = 0.99,method = "BL"))
  } else {
    test <- x
  }
  n <- n + i
}
n
```


```{r}
zCompositions::cmultRepl(count_all_list[[6]],z.warning = 0.99)
count_all_list[[6]]
count_all_list_imputed[[7]]
count_all_list_imputed
```


```{r}
count_all_list_imputed_clr <- lapply(count_all_list_imputed, CLR)
prob_all_list_imputed_clr <- lapply(prob_all_list_imputed, CLR)
```

```{r}

count_all_list[[9]]
prob_all_list[[9]]
count_all_list_imputed[[9]]
prob_all_list_imputed[[9]]

```


```{r}
#include unknown
tool_lrv <- lapply(count_all_list_imputed_clr, LR.VAR)
```



```{r}
## no unknown
#from count
count_all_nounknown_imputed <- impute_fn(count_all_nounknown_list)

#from prop
prob_all_nounknown_imputed <- impute_fn(prob_all_nounknown)

prob_all_nounknown_imputed_clr <- lapply(prob_all_nounknown_imputed, CLR)

tool_nounknown_lrv <- lapply(prob_all_nounknown_imputed_clr, LR.VAR)
```

```{r}
#diversify 
#sd-of-cellstate-per-donor_mean_nounknown
sd_mean_nounknown <- lapply(prob_all_nounknown, function(x) { # per tool
  x <- apply(x,1,FUN = sd) # sd of cellstate per donor
  x <- mean(x) # mean of sd
  return(x)
})

```


```{r}
#choose best tool
tool_lrv_vec <- unlist(tool_lrv)
names(tool_lrv_vec) <- names(tool_lrv)

tool_lrv_nounknown_vec <- unlist(tool_nounknown_lrv)
names(tool_lrv_nounknown_vec) <- names(tool_nounknown_lrv)

sd_mean_nounknown_vec <- unlist(sd_mean_nounknown)
names(sd_mean_nounknown_vec) <- names(sd_mean_nounknown)


tools_matric <- data.frame(lrv = tool_lrv_vec, 
                           lrv_nounknown = tool_lrv_nounknown_vec,
                           sd_mean_nounknown = sd_mean_nounknown_vec,
                           unknown_mean = (1-prob_all_unknown_mean),
                           unknown_median = (1 - prob_all_unknown_median),
                           unknown_mean_weighted = (1- unlist(prob_all_unknown_mean_weighted)))


tools_matric
```

```{r}
library(MCDA)
tool_name <- colnames(tools_matric)
tool_name
```


```{r}
weights <- setNames(c(1,1,1,1,1,1), colnames(tools_matric))
impacts <- c("+","+","+","+","+","+") # For topsis

pick <- c(2,3,4)
```


```{r}
#Topsis
tools_topsis_score <- topsis(decision = as.matrix(tools_matric[,tool_name[pick]]), weights = weights[pick], impacts = impacts[pick])

tools_topsis_score$alt.row <- rownames(tools_matric)

colnames(tools_topsis_score)[1] <- "tool"

tools_topsis_score_metric <- merge(tools_topsis_score,rownames_to_column(tools_matric,var = "tool"),by = "tool")

tools_topsis_score_metric <- tools_topsis_score_metric %>% arrange(rank)

tools_topsis_score_metric

topsis <- column_to_rownames(tools_topsis_score,var = "tool")
colnames(topsis)[1] <- "topsis"
topsis <- topsis[,-2,drop = FALSE]
```

```{r}
# MCMD: weightedSum 
normalizationtypes <- rep("rescaling",times = ncol(tools_matric))
names(normalizationtypes) <- tool_name

tools_matric_norm <- normalizePerformanceTable(
  tools_matric, normalizationTypes = normalizationtypes,
  criteriaIDs = tool_name)

weightedSum <- data.frame(weightedSum = weightedSum(tools_matric_norm,
            criteriaWeights = weights[pick],
            criteriaIDs = tool_name[pick]))

```



```{r}
# "waspasR" 
library("waspasR")
# tools_matric <- tools_matric %>% select(-unknown_mean_weighted_revert)
# tools_matric$unknown_mean_weighted_revert <- 1 -tools_matric$unknown_mean_weighted

flags_input <- rep("Benefit",times = ncol(tools_matric))

waspas_df <- rbind(t(data.frame(F = flags_input[pick],
           W = weights[pick]/sum(weights[pick]))),
           C = colnames(tools_matric)[pick],
      tools_matric[pick])

waspas_df <- as.tibble(rownames_to_column(waspas_df,var = "tool"))

waspas_raw <- waspasR_edited(waspas_df,lambda = 0.5)

waspas <- column_to_rownames(waspas_raw,var = "Alternative") 
waspas <- waspas[!rownames(waspas)%in% c("W","F"),c("WSM_Rank","WPM_Rank","WASPAS_Rank")] 
waspas
```

```{r}
topsis
weightedSum
waspas
```


```{r}
metric <- cbind(topsis,weightedSum,waspas)

metric <- metric %>% arrange(desc(topsis))

metric <- metric %>% arrange(desc(WASPAS_Rank))
```








 

```{r}
# library
library(ggplot2)
 
# create a dataset
specie <- c(rep("sorgho" , 3) , rep("poacee" , 3) , rep("banana" , 3) , rep("triticum" , 3) )
condition <- rep(c("normal" , "stress" , "Nitrogen") , 4)
value <- abs(rnorm(12 , 0 , 15))
data <- data.frame(specie,condition,value)
```


```{r}
tool <- "tool"
proportion <- "proportion"
gathercols <- colnames(prob_all)[!colnames(prob_all) %in% c("cellstate","donor_id")]

prob_all_long <- gather(prob_all, tool, proportion, gathercols)
prob_all_long$tool <- factor(prob_all_long$tool,levels = rownames(metric))

prob_all_long$donor_id <- factor(prob_all_long$donor_id,level = donor_id_bysize)
ggplot(prob_all_long, aes(fill=cellstate, y=proportion, x=donor_id)) + 
    geom_bar(position="fill", stat="identity") +
  facet_wrap(~tool) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1,size = 3))

```

```{r}
count <- "count"



count_all_long <- gather(count_all, tool, count, gathercols)
count_all_long$tool <- factor(count_all_long$tool,levels = rownames(metric))
count_all_long$donor_id <- factor(count_all_long$donor_id,level = donor_id_bysize)

ggplot(count_all_long, aes(fill=cellstate, y=count, x=donor_id)) + 
    geom_bar(position="stack", stat="identity") +
  facet_wrap(~tool) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1,size = 3))
```
```{r}
# Do sankey
library(ggsankey)
library(ggplot2)
library(patchwork)
library(ggtext)
my_colors <- c("red", "green", "blue", "gray", "purple", "orange")
plots_list <- list()

anno_cellstate_meta_control_sortcol <- 
  cbind(anno_cellstate_meta_control[,1,drop = FALSE],
        anno_cellstate_meta_control[,rownames(metric)])
donor_id_bysize <- names(sort(table(anno_cellstate_meta_control_sortcol$donor_id),decreasing = TRUE))

anno_cellstate_meta_control_sortcol$donor_id <- factor(anno_cellstate_meta_control_sortcol$donor_id,levels = donor_id_bysize)

for (i in levels(anno_cellstate_meta_control_sortcol$donor_id)) {
  anno_cellstate_meta_each <- anno_cellstate_meta_control_sortcol[anno_cellstate_meta_control_sortcol$donor_id== i,]
  anno_cellstate_meta_each <- anno_cellstate_meta_each %>% select(-1)
  all.sankey <- anno_cellstate_meta_each
  colnames(all.sankey) <- gsub("_no_unknown","",colnames(all.sankey))
  df <- all.sankey %>%
    make_long(colnames(all.sankey))

  # Chart 1
  pl <- ggplot(df, aes(
    x = x,
    next_x = next_x,
    node = node,
    next_node = next_node,
    fill = factor(node),
    label = node
  ))
  pl <- pl + geom_sankey(
    flow.alpha = 0.5,
    node.color = "black",
    show.legend = FALSE
  )
  #pl <- pl + geom_sankey_label(size = 2, color = "black", fill = "white")
  pl <- pl + theme_bw()
  pl <- pl + theme(legend.position = "none")
  pl <- pl + theme(
    axis.title = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    axis.text.x = element_blank(),
    panel.grid = element_blank()
  )

  pl <- pl + labs(subtitle = paste(i,"; ",
                                   round(nrow(anno_cellstate_meta_each)*100/nrow(anno_cellstate_meta),digits = 2),"%",
                                   sep = ""))
  pl <- pl + labs(fill = "Nodes")
  pl <- pl + scale_fill_manual(values = my_colors)
  plots_list[[i]] <- pl
}

combined_plot <- wrap_plots(plots_list, ncol = 6)


# Assuming 'my_colors' is your color vector and 'df' is your data frame
# Map colors to factor levels
color_mapping <- setNames(my_colors, levels(factor(df$node)))

# Construct the caption string dynamically
caption_text <- paste(sapply(names(color_mapping), function(node) {
  sprintf("<span style='color: %s;'>%s</span>", color_mapping[node], node)
}), collapse = " ")

combined_plot + plot_annotation(
    title = paste0(paste(setdiff(levels(factor(df$node)),"unknown"),collapse = ", ") ," cell states","; ",unknown,"; ",run),
    subtitle = caption_text,
    caption = paste(colnames(anno_cellstate_meta_control_sortcol)[-1],collapse = "; "),
    theme = theme(plot.subtitle = element_markdown())
)


```
#cv (unused)
```{r}
# # Assuming count_all is your data frame with columns: cellstate, donor_id, tool1, tool2, ...
# 
# # Load required libraries
# library(dplyr)
# 
# # Function to calculate Coefficient of Variation (CV)
# cv <- function(x) {
#   sd_val <- sd(x)
#   mean_val <- mean(x)
#   cv_result <- sd_val / mean_val * 100  # Multiply by 100 for percentage
#   return(cv_result)
# }
# 
# # Identify the column indices for cell types
# celltype_columns <- 3:ncol(count_all)  # Assuming cell type proportions start from the third column
# 
# # Print the column names to check
# print(colnames(count_all))
# 
# # Print the indices to check
# print(celltype_columns)
# # Apply CV function to each cell type column
# tool_cv <- data.frame(cellstate =levels(count_all$cellstate))
# tool_cv$cellstate <- as.factor(tool_cv$cellstate)  
# for (i in 3:ncol(count_all)) {
#   prop_tool <- count_all[,c(1,2,i)]
#   tool_name <- colnames(prop_tool)[3]
#   colnames(prop_tool)[3] <- "tool"
#   prop_tool <-  prop_tool %>% group_by(cellstate) %>% summarize(
#   avg_cv = cv(tool))
#   colnames(prop_tool)[2] <- tool_name
#   tool_cv <- merge(tool_cv,prop_tool,by = "cellstate")
# } 
# 
# tool_cv

```
