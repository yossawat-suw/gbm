
```{r}
source("default.R")
```

```{r}
library(parallel)
library(tidyverse)
library(Seurat)
library(mclust)
library(MASS)
library(scID)
library(biomod2)
```



```{r}
print("set parameter")
# input cell
object <- "all"

celltypes <- c("celltype", "celltype_merge")
celltype <- celltypes[2]


# For reference based
merges <- c("6metamodules", "4_merge_metamodules", "4_merge_metamodules_3celltypes", "4_merge_metamodules_mes")
merge <- merges[3]
# pick which celltype to be analyse

all_celltypes <- c("AClike", "MESlike", "NPClike", "OPClike")
chosen_celltypes <- all_celltypes[c(1, 3, 4)]
```



<!-- #clustifyr -->
<!-- ```{r} -->
<!-- library(clustifyr) -->
<!-- library(Seurat) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- neftel.smt <- readRDS("./../output/smrt_mal"); neftel.smt <- subset(neftel.smt,idents = chosen_celltypes); -->
<!-- ``` -->
<!-- ```{r} -->
<!-- new_ref_matrix <- seurat_ref( -->
<!--   seurat_object = neftel.smt,        # SeuratV3 object -->
<!--   cluster_col = celltype,    # name of column in meta.data containing cell identities -->
<!-- ) -->
<!-- ``` -->


<!-- ```{r} -->
<!-- gbm <- readRDS("./../output/seurat_gbm_qc") -->
<!-- gbm.list <- SplitObject(gbm, split.by = "split") -->
<!-- ``` -->

<!-- ```{r} -->
<!-- gbm.list[["run2_radiated_E31N"]] <- merge(gbm.list[["run2_radiated_E31N"]], y=gbm.list[["run1_radiated_E31N"]]) -->
<!-- gbm.list[["run2_control_E31N"]] <- merge(gbm.list[["run2_control_E31N"]], y=gbm.list[["run1_control_E31N"]]) -->
<!-- gbm.list[["run2_radiated_E26N"]] <- merge(gbm.list[["run2_radiated_E26N"]], y=gbm.list[["run1_radiated_E26N"]]) -->
<!-- gbm.list[["run2_radiated_E24N"]] <- merge(gbm.list[["run2_radiated_E24N"]], y=gbm.list[["run1_radiated_E24N"]]) -->
<!-- gbm.list[c("run1_radiated_E24N","run1_radiated_E26N","run1_control_E31N","run1_radiated_E31N")] <- NULL -->
<!-- ``` -->

<!-- ```{r} -->
<!-- library(parallel) -->
<!-- n.cores <- 3 -->
<!-- system.time(gbm.list.res <- mclapply(X = gbm.list, mc.cores = n.cores, FUN = function(x)  { -->
<!--   x <- NormalizeData(x,verbose = FALSE) -->
<!--   allgenes <- rownames(x) -->
<!--   x <- FindVariableFeatures(x,verbose = FALSE) -->
<!--   x <- ScaleData(x, features = allgenes ,verbose = FALSE) -->
<!--   x <- RunPCA(x, verbose = FALSE) -->
<!--   x <- FindNeighbors(x, reduction = "pca", dims = 1:20, verbose = FALSE) -->
<!--   x <- FindClusters(x, resolution = 1, verbose = FALSE) -->

<!--   res <- clustify( -->
<!--           input = x,       -->
<!--           ref_mat = new_ref_matrix,     -->
<!--           cluster_col = "RNA_snn_res.1",  -->
<!--           obj_out = TRUE,threshold = 0,verbose = TRUE )      -->
<!--   return(res@meta.data[c("type","r")]) -->
<!-- })) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- names(gbm.list.res) <- NULL -->
<!-- res.ref.df <- NULL -->
<!-- res.ref.df <- do.call(rbind,gbm.list.res) -->

<!-- colnames(res.ref.df) <- c("clustifyr_ref","r_ref") -->
<!-- ``` -->

<!-- ```{r} -->
<!-- write.csv(res.ref.df,paste0("./../output/clustifyr_",object,"_",merge,".csv"),row.names = TRUE) -->
<!-- ``` -->






<!-- #scID -->
<!-- ```{r} -->
<!-- if (!require("scID")) devtools::install_github("BatadaLab/scID",dependencies = TRUE,force = TRUE) -->
<!-- # target_gem <- readRDS(file="./../data/example/scID/target_gem.rds") -->
<!-- # reference_gem <- readRDS(file="./../data/example/scID/reference_gem.rds") -->
<!-- # reference_clusters <- readRDS(file="./../data/example/scID/reference_clusters.rds") -->
<!-- ``` -->

<!-- ```{r} -->
<!-- # Ref -->
<!-- print("process neftel") -->

<!-- neftel.smt <- readRDS("./../output/smrt_mal"); neftel.smt <- subset(neftel.smt,idents = chosen_celltypes); -->

<!-- #neftel.smt <- readRDS("./../output/smrt_mal"); neftel.smt$celltype_merge <- as.character(neftel.smt$celltype_merge); neftel.smt@meta.data[!neftel.smt$celltype_merge == "MESlike","celltype_merge"] <- "non_MES"; neftel.smt$celltype_merge <- as.factor(neftel.smt$celltype_merge); -->


<!-- reference_gem <- as.matrix(neftel.smt@assays$norm@data) -->
<!-- reference_clusters <- as.factor(neftel.smt@meta.data[,celltype]) -->
<!-- names(reference_clusters) <- rownames(neftel.smt@meta.data) -->
<!-- ``` -->


<!-- ```{r} -->
<!-- # Target -->
<!-- print("process gbm") -->
<!-- gbm <- readRDS("./../output/seurat_gbm_qc") -->

<!-- gbm.list <- SplitObject(gbm, split.by = "split") -->
<!-- gbm.list[["run2_radiated_E31N"]] <- merge(gbm.list[["run2_radiated_E31N"]], y=gbm.list[["run1_radiated_E31N"]]) -->
<!-- gbm.list[["run2_control_E31N"]] <- merge(gbm.list[["run2_control_E31N"]], y=gbm.list[["run1_control_E31N"]]) -->
<!-- gbm.list[["run2_radiated_E26N"]] <- merge(gbm.list[["run2_radiated_E26N"]], y=gbm.list[["run1_radiated_E26N"]]) -->
<!-- gbm.list[["run2_radiated_E24N"]] <- merge(gbm.list[["run2_radiated_E24N"]], y=gbm.list[["run1_radiated_E24N"]]) -->
<!-- gbm.list[c("run1_radiated_E24N","run1_radiated_E26N","run1_control_E31N","run1_radiated_E31N")] <- NULL -->
<!-- ``` -->

<!-- ```{r} -->
<!-- rm(gbm,neftel.smt) -->
<!-- gc() -->
<!-- ``` -->



<!-- ```{r} -->
<!-- print("run scID") -->
<!-- print(paste0("cores being used: ",parallel::detectCores())) -->
<!-- gbm.list.res <- lapply(X = gbm.list, FUN = function(x)  { -->
<!-- #gbm.list.res <- mclapply(X = gbm.list, mc.cores = parallel::detectCores(), FUN = function(x)  { -->
<!-- #gbm.list.res <- mclapply(X = gbm.list, mc.cores = parallel::detectCores(), FUN = function(x)  { -->
<!--   x <- NormalizeData(x,normalization.method = "RC",verbose = FALSE) -->
<!--   x <- as.matrix(x@assays$RNA@data) -->
<!--   # If want to set estimate_weights_from_target = TRUE, need older version of biomod2 (3.5.1) -->
<!--   scID_output <- scid_multiclass(target_gem = x, reference_gem = reference_gem, reference_clusters = reference_clusters, logFC = 0.6, only_pos = FALSE,  estimate_weights_from_target = TRUE, normalize_reference = FALSE) -->
<!--   return(scID_output) -->
<!--   gc() -->
<!-- }) -->
<!-- print("finish scID") -->
<!-- ``` -->


<!-- ```{r} -->
<!-- print("save RDS") -->
<!-- saveRDS(gbm.list.res, file = paste0("./../output/scID_",object,"_",merge)) -->
<!-- ``` -->



<!-- ```{r} -->
<!-- res.df <- data.frame() -->
<!-- for (i in gbm.list.res) { -->
<!--   res.each.df <- cbind(as.data.frame(i$labels, stringsAsFactors = TRUE),data.frame(t(i$scores))) -->
<!--   res.df <- rbind(res.df,res.each.df) -->
<!-- } -->
<!-- colnames(res.df)[1] <- "scID" -->
<!-- library(tibble) -->
<!-- res.df <- rownames_to_column(res.df) -->
<!-- colnames(res.df)[1] <- "cell_id" -->

<!-- ``` -->




<!-- ```{r} -->
<!-- print("res.df") -->
<!-- write.csv(res.df,paste0("./../output/scID_",object,"_",merge,".csv"),row.names = FALSE) -->
<!-- ``` -->



#scID without "unassigned"
```{r}
library(scID)
library(Seurat)
```

```{r}
# Ref
print("load neftel")
neftel.smt <- readRDS("./../output/smrt_mal")
neftel.smt <- subset(neftel.smt, idents = chosen_celltypes)
reference_gem <- as.matrix(neftel.smt@assays$norm@data)
reference_clusters <- as.factor(neftel.smt@meta.data[, celltype])
names(reference_clusters) <- rownames(neftel.smt@meta.data)
```


```{r}
print("load gbm")
# Target
gbm <- readRDS("./../output/seurat_gbm_qc")
gbm.list <- SplitObject(gbm, split.by = "split")
gbm.list[["run2_radiated_E31N"]] <- merge(gbm.list[["run2_radiated_E31N"]], y = gbm.list[["run1_radiated_E31N"]])
gbm.list[["run2_control_E31N"]] <- merge(gbm.list[["run2_control_E31N"]], y = gbm.list[["run1_control_E31N"]])
gbm.list[["run2_radiated_E26N"]] <- merge(gbm.list[["run2_radiated_E26N"]], y = gbm.list[["run1_radiated_E26N"]])
gbm.list[["run2_radiated_E24N"]] <- merge(gbm.list[["run2_radiated_E24N"]], y = gbm.list[["run1_radiated_E24N"]])
gbm.list[c("run1_radiated_E24N", "run1_radiated_E26N", "run1_control_E31N", "run1_radiated_E31N")] <- NULL
```


```{r}
rm(gbm, neftel.smt)
```


```{r}

scid_multiclass_edited <- function(target_gem = NULL, reference_gem = NULL,
                                   reference_clusters = NULL, markers = NULL,
                                   logFC = 0.5, normalize_reference = TRUE,
                                   estimate_weights_from_target = FALSE,
                                   weights = NULL, only_pos = FALSE) {
  # state the variable that will be use in the function
  markers <- markers.glob

  # ----------------------------------------------------------------------------------------------------
  # Data pre-processing
  # ----------------------------------------------------------------------------------------------------
  if (is.null(reference_gem) && is.null(reference_clusters) && is.null(markers)) {
    stop("Please provide either clustered reference data or list of markers for each reference cluster")
  }
  if (!is.null(reference_gem) && !is.null(reference_clusters)) {
    # Check all reference cells have a cluster ID
    common_cells <- intersect(names(reference_clusters), colnames(reference_gem))
    if (length(common_cells) == 0) {
      stop("None  of the reference cells has a cluster ID. Please check the reference_clusters list provided.")
    } else {
      reference_gem <- reference_gem[, common_cells]
      rownames(reference_gem) <- make.names(toupper(rownames(reference_gem)), unique = TRUE)

      # Remove genes that are zero across all cells
      reference_gem <- reference_gem[which(rowSums(reference_gem) != 0), ]
      reference_clusters <- reference_clusters[common_cells]
    }
  }

  if (!is.null(markers)) {
    # Check markers have gene and cluster columns
    if (length(intersect(c("gene", "cluster"), colnames(markers))) != 2) {
      stop("Please provide a data frame of markers with gene and cluster in columns")
    }
    markers$gene <- toupper(markers$gene)
  }


  # Target
  rownames(target_gem) <- make.names(toupper(rownames(target_gem)), unique = TRUE)
  # Remove genes that are zero across all cells
  target_gem <- target_gem[which(rowSums(target_gem) != 0), ]

  # ----------------------------------------------------------------------------------------------------
  # Stage 1: Find signature genes from reference data
  # ----------------------------------------------------------------------------------------------------
  if (is.null(markers)) {
    # Filter out signature genes that are not present in the target data
    markers <- markers[which(markers$gene %in% rownames(target_gem)), ]

    celltypes <- unique(markers$cluster)

    if (estimate_weights_from_target) {
      rm(reference_gem, reference_clusters)
    }
  } else {
    markers <- markers[which(markers$gene %in% rownames(target_gem)), ]
    celltypes <- unique(markers$cluster)
  }

  # Min-max normalization of target gem
  target_gem_norm <- t(apply(target_gem[unique(markers$gene), ], 1, function(x) normalize_gene(x)))
  target_gem_norm <- target_gem_norm[complete.cases(target_gem_norm), ]

  # ----------------------------------------------------------------------------------------------------
  # Stage 2: Weight signature genes
  # ----------------------------------------------------------------------------------------------------
  if (is.null(weights)) {
    if (estimate_weights_from_target) {
      weights <- list()
      for (i in 1:length(celltypes)) {
        celltype_markers <- markers[which(markers$cluster == celltypes[i]), ]
        positive_markers <- celltype_markers$gene[which(celltype_markers$avg_log2FC > 0)]
        negative_markers <- celltype_markers$gene[which(celltype_markers$avg_log2FC < 0)]
        training_groups <- choose_training_set(target_gem, positive_markers, negative_markers)
        signature_genes <- c(positive_markers, negative_markers)
        gene.weights <- scID_weight(target_gem_norm[signature_genes, , drop = FALSE], training_groups$in_pop, training_groups$out_pop)
        # If only positive markers are selected, truncate all negative weights to 0
        if (only_pos) {
          gene.weights[which(gene.weights < 0)] <- 0
        }
        # Make Inf weights 0
        gene.weights[is.infinite(gene.weights)] <- 0
        weights[[as.character(celltypes[i])]] <- gene.weights
      }
      names(weights) <- celltypes
    } else {
      if (!is.null(reference_gem) && !is.null(reference_clusters)) {
        weights <- list()
        # Normalize reference gem
        ref_gem_norm <- t(apply(reference_gem[unique(markers$gene), ], 1, function(x) normalize_gene(x)))
        ref_gem_norm <- ref_gem_norm[complete.cases(ref_gem_norm), ]
        for (i in 1:length(celltypes)) {
          signature_genes <- markers$gene[which(markers$cluster == celltypes[i])]
          true_cells <- names(reference_clusters)[which(reference_clusters == as.character(celltypes[i]))]
          false_cells <- setdiff(names(reference_clusters), true_cells)
          gene.weights <- scID_weight(gem = ref_gem_norm[signature_genes, , drop = FALSE], true_cells, false_cells)

          weights[[as.character(celltypes[i])]] <- gene.weights
          # If only positive markers are selected, truncate all negative weights to 0
          if (only_pos) {
            gene.weights[which(gene.weights < 0)] <- 0
          }
        }
        # Won't need reference data any more, remove for efficiency
        rm(reference_gem, reference_clusters, ref_gem_norm)
      } else {
        stop("Please provide reference data in order to calculate weights, choose to estimate weights from target data, or provide precompted gene weights.")
      }
    }
  }

  #----------------------------------------------------------------------------------------------------
  # Stage 3: Find scores and putative matches
  # ----------------------------------------------------------------------------------------------------

  scores <- data.frame(matrix(NA, length(celltypes), ncol(target_gem)), row.names = celltypes)
  colnames(scores) <- colnames(target_gem)

  full_scores <- data.frame(matrix(NA, length(celltypes), ncol(target_gem)), row.names = celltypes)
  colnames(full_scores) <- colnames(target_gem)

  for (i in 1:length(celltypes)) {
    celltype <- as.character(celltypes[i])
    signature <- intersect(names(weights[[celltype]]), rownames(target_gem_norm))
    weighted_gem <- weights[[celltype]][signature] * target_gem_norm[signature, , drop = FALSE]
    # Check if whole weighted gem is 0 (when all gene weighst are zero)
    if (all(weighted_gem == 0)) {
      full_scores[as.character(celltype), ] <- rep(0, ncol(full_scores))
      print(paste("oh no", i))
    } else {
      score <- colSums(weighted_gem) / sqrt(sum(weights[[celltype]]^2))

      matches <- final_populations_edited(score)

      scores[as.character(celltype), matches] <- scale(score[matches])
      full_scores[as.character(celltype), ] <- score
    }
  }

  # Resolve multi-class assignments

  labels <- apply(scores, 2, function(x) {
    ifelse(all(is.na(x)), "unassigned", rownames(scores)[which(x == max(x, na.rm = T))])
  })

  # Add convert unassigned to random assigned one
  # Check first whether we have unassigned or not
  unassigned_index <- which(labels == "unassigned")

  labels_edited <- labels
  full_scores_unassigned <- NA

  if (length(unassigned_index) > 0) {
    full_scores_unassigned <- full_scores[, unassigned_index, drop = FALSE]

    labels_unassigned <- apply(full_scores_unassigned, 2, function(x) {
      rownames(full_scores_unassigned)[which(x == max(x, na.rm = T))]
    })
    labels_edited[unassigned_index] <- labels_unassigned
  } else {
    message("no unassigned")
  }

  # return result
  list(scores = scores, full_scores = full_scores, labels = labels, labels_edited = labels_edited)
}

final_populations_edited <- function(score) {
  fit <- suppressMessages(mclust::densityMclust(score, G = 1:4, plot = FALSE, verbose = FALSE))

  # Calculate average scID score per group of cells
  avgScore <- rep(NA, length(unique(fit$classification)))
  names(avgScore) <- unique(fit$classification)
  for (ID in names(avgScore)) avgScore[ID] <- mean(score[names(which(fit$classification == ID))])

  matches <- names(fit$classification)[which(fit$classification == names(which(avgScore == max(avgScore))))]

  matches
}

find_markers_edited <- function(
    reference_gem, reference_clusters, logFC, only.pos,
    normalize_reference) {
  library(Seurat)
  so_ref <- CreateSeuratObject(reference_gem)
  if (normalize_reference) {
    so_ref <- suppressMessages(NormalizeData(so_ref, verbose = FALSE))
  }
  so_ref <- suppressMessages(ScaleData(so_ref, verbose = FALSE))
  Idents(so_ref) <- as.factor(reference_clusters)
  markers <- suppressMessages(FindAllMarkers(so_ref,
    test.use = "MAST",
    only.pos = only.pos, logfc.threshold = logFC, verbose = FALSE
  ))
  markers
}
```





```{r}
print("find_markers_edited")
markers.glob <- find_markers_edited(reference_gem, reference_clusters, logFC = 0.5, only.pos = FALSE, normalize_reference = FALSE)
```


```{r}
# saveRDS(markers.glob,"./../output/markers_glob_scID")
# markers.glob <- readRDS("./../output/markers_glob_scID")
```

```{r}
library(parallel)
# n.cores <- 2
n.cores <- parallel::detectCores()
# n.cores <- parallel::detectCores() - 3
all.tasks <- length(gbm.list)


# gbm.list.res <- lapply(X = gbm.list, FUN = function(x)  {

print("load run sc_id_edited")
gbm.list.res <- mclapply(X = gbm.list, mc.cores = n.cores, FUN = function(x) {


  x <- NormalizeData(x, normalization.method = "RC", verbose = FALSE)
  x <- as.matrix(x@assays$RNA@data)
  # If want to set estimate_weights_from_target = TRUE, need older version of biomod2 (3.5.1)
  # scID_output <- tryCatch(scid_multiclass_edited(target_gem = x, reference_gem = reference_gem, reference_clusters = reference_clusters, logFC = 0.6, only_pos = FALSE,  estimate_weights_from_target = TRUE, normalize_reference = FALSE), error=function(e) NA)
  scID_output <- scid_multiclass_edited(target_gem = x, reference_gem = reference_gem, reference_clusters = reference_clusters, logFC = 0.6, only_pos = FALSE, estimate_weights_from_target = TRUE, normalize_reference = FALSE)

  #  gc()
  return(scID_output)
})

print("finish")
```


```{r}

saveRDS(gbm.list.res, file = paste0("./../output/scID_", object, "_", merge, "_allassigned"))
```




```{r}
res.df <- data.frame()
for (i in gbm.list.res) {
  res.each.df <- cbind(as.data.frame(i$labels, stringsAsFactors = TRUE), as.data.frame(i$labels_edited, stringsAsFactors = TRUE), data.frame(t(i$scores)))
  res.df <- rbind(res.df, res.each.df)
}
colnames(res.df)[1] <- "scID"
colnames(res.df)[2] <- "scID_edited"
```


```{r}
# gbm.meta <- read.csv("./../output/gbm_meta.csv",row.names = 1)
```


```{r}
# scid <- merge(res.df, gbm.meta, by = 'row.names', all = TRUE)
```


```{r}
print("save result")
write.csv(res.df, paste0("./../output/scID_", object, "_", merge, "_allassigned", ".csv"), row.names = TRUE)
```




#singleR
<!-- ```{r} -->
<!-- library(SingleR) -->
<!-- library(scran) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- neftel.smt <- readRDS("./../output/smrt_mal"); neftel.smt <- subset(neftel.smt,idents = chosen_celltypes); -->
<!-- neftel.smt.sce <- as.SingleCellExperiment(DietSeurat(neftel.smt,data = TRUE, counts = FALSE,scale.data = FALSE)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- gbm <- readRDS("./../output/seurat_gbm_qc") -->
<!-- gbm.list <- SplitObject(gbm, split.by = "split") -->
<!-- ``` -->


<!-- ```{r} -->
<!-- gbm.list[["run2_radiated_E31N"]] <- merge(gbm.list[["run2_radiated_E31N"]], y=gbm.list[["run1_radiated_E31N"]]) -->
<!-- gbm.list[["run2_control_E31N"]] <- merge(gbm.list[["run2_control_E31N"]], y=gbm.list[["run1_control_E31N"]]) -->
<!-- gbm.list[["run2_radiated_E26N"]] <- merge(gbm.list[["run2_radiated_E26N"]], y=gbm.list[["run1_radiated_E26N"]]) -->
<!-- gbm.list[["run2_radiated_E24N"]] <- merge(gbm.list[["run2_radiated_E24N"]], y=gbm.list[["run1_radiated_E24N"]]) -->
<!-- gbm.list[c("run1_radiated_E24N","run1_radiated_E26N","run1_control_E31N","run1_radiated_E31N")] <- NULL -->
<!-- ``` -->

<!-- ```{r} -->
<!-- system.time(gbm.list.res <- mclapply(X = gbm.list, mc.cores = n.cores, FUN = function(x)  { -->
<!--   x <- NormalizeData(x,verbose = FALSE) -->
<!--   x <- DietSeurat(x,data = TRUE, counts = FALSE,scale.data = FALSE) -->
<!--   x <- as.SingleCellExperiment(x) -->
<!--   pred.grun <- SingleR(test=x, ref=neftel.smt.sce, labels=neftel.smt.sce@colData[,celltype], de.method="wilcox") -->
<!--   return(pred.grun) -->
<!-- }))   -->
<!-- ``` -->
<!-- ```{r} -->
<!-- res.df <- DataFrame() -->
<!-- res.df <- do.call(rbind,gbm.list.res) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- res.df  -->
<!-- ``` -->

<!-- ```{r} -->
<!-- saveRDS(res.df,file = paste0("./../output/singleR_",object,"_",merge)) -->

<!-- res.df <- readRDS(paste0("./../output/singleR_",object,"_",merge)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- library(dplyr) -->
<!-- res.df <- data.frame(res.df) -->
<!-- res.df <- res.df %>% relocate(c("labels","pruned.labels"),.before = 1) -->
<!-- colnames(res.df)[1] <- "singleR" -->
<!-- res.df -->
<!-- ``` -->

<!-- ```{r} -->
<!-- write.csv(res.df,paste0("./../output/singleR_",object,"_",merge,".csv"),row.names = TRUE) -->
<!-- ``` -->


#CHETAH
<!-- ```{r} -->
<!-- # Load the package -->
<!-- library(CHETAH) -->
<!-- library(Seurat) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- neftel.smt <- readRDS("./../output/smrt_mal"); neftel.smt <- subset(neftel.smt,idents = chosen_celltypes);  -->

<!-- #from tutorial it use log-normalization so use the default from seurat -->
<!-- neftel.smt <- DietSeurat(neftel.smt, assays = "RNA") -->
<!-- neftel.smt <- DietSeurat(neftel.smt,data = TRUE, counts = FALSE,scale.data = FALSE) -->

<!-- neftel.smt.sce <- as.SingleCellExperiment(neftel.smt) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- neftel.smt.sce@colData <- neftel.smt.sce@colData[celltype]  -->

<!-- #Change name because input need this -->
<!-- colnames(neftel.smt.sce@colData) <- 'celltypes' -->
<!-- ``` -->
<!-- ```{r} -->
<!-- #QC -->
<!-- ribo <- read.table("./../data/ribosomal.txt", header = FALSE, sep = '\t') -->
<!-- neftel.smt.sce <- neftel.smt.sce[!rownames(neftel.smt.sce) %in% ribo[,1], ] -->
<!-- ``` -->
<!-- ```{r} -->
<!-- CorrelateReference(ref_cells = neftel.smt.sce) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- ClassifyReference(ref_cells = neftel.smt.sce,ref_c = "logcounts") -->
<!-- ``` -->


<!-- ```{r} -->
<!-- gbm <- readRDS("./../output/seurat_gbm_qc") -->
<!-- gbm.list <- SplitObject(gbm, split.by = "split") -->

<!-- gbm.list[["run2_radiated_E31N"]] <- merge(gbm.list[["run2_radiated_E31N"]], y=gbm.list[["run1_radiated_E31N"]]) -->
<!-- gbm.list[["run2_control_E31N"]] <- merge(gbm.list[["run2_control_E31N"]], y=gbm.list[["run1_control_E31N"]]) -->
<!-- gbm.list[["run2_radiated_E26N"]] <- merge(gbm.list[["run2_radiated_E26N"]], y=gbm.list[["run1_radiated_E26N"]]) -->
<!-- gbm.list[["run2_radiated_E24N"]] <- merge(gbm.list[["run2_radiated_E24N"]], y=gbm.list[["run1_radiated_E24N"]]) -->
<!-- gbm.list[c("run1_radiated_E24N","run1_radiated_E26N","run1_control_E31N","run1_radiated_E31N")] <- NULL -->
<!-- ``` -->


<!-- ```{r} -->

<!-- library(parallel) -->
<!-- #n.cores <- parallel::detectCores() - 1 -->
<!-- n.cores <- 5 -->
<!-- system.time(gbm.list.res <- mclapply(X = gbm.list, mc.cores = n.cores, FUN = function(x)  { -->
<!-- #system.time(gbm.list.res <- lapply(X = gbm.list[4:5],  FUN = function(x)  { -->
<!--   x <- NormalizeData(x,verbose= FALSE) -->
<!--   x <- FindVariableFeatures(x, verbose= FALSE) -->
<!--   x <- ScaleData(x,verbose = FALSE) -->
<!--   x <- RunPCA(x, verbose = FALSE) -->
<!--   x <- FindNeighbors(x, reduction = "pca", dims = 1:20, verbose = FALSE) -->
<!--   x <- FindClusters(x, resolution = 1, verbose = FALSE) -->
<!--   x <- RunUMAP(x, dims = 1:20, verbose =FALSE) -->

<!--   x <- DietSeurat(x,counts = FALSE,data = TRUE,scale.data = FALSE, dimreducs = "umap") -->
<!--   x <- as.SingleCellExperiment(x) -->
<!--   #x@colData <- x@colData[c("orig.ident")] -->

<!--   x <- CHETAHclassifier(input = x, -->
<!--                               ref_cells = neftel.smt.sce,print_steps = FALSE) -->
<!--   x <- Classify(x, 0) -->
<!--   return(x@colData["celltype_CHETAH"]) -->

<!-- })) -->


<!-- ``` -->


<!-- ```{r} -->
<!-- res.df <- do.call(rbind,gbm.list.res) -->

<!-- ``` -->
<!-- ```{r} -->
<!-- table(res.df$celltype_CHETAH) -->
<!-- colnames(res.df)[1] <- "CHETAH" -->
<!-- ``` -->

<!-- ```{r} -->
<!-- write.csv(res.df,paste0("./../output/CHETAH_",object,"_",merge,".csv"),row.names = TRUE) -->
<!-- ``` -->




#scmap
<!-- ```{r} -->
<!-- library(scmap) -->
<!-- library(SingleCellExperiment) -->

<!-- neftel.smt <- readRDS("./../output/smrt_mal"); neftel.smt <- subset(neftel.smt,idents = chosen_celltypes); -->
<!-- neftel.smt.norm <-  as.matrix(neftel.smt@assays$norm@data) -->
<!-- celltype.df <- neftel.smt@meta.data[celltype] -->

<!-- neftel.smt.sce <- SingleCellExperiment(assays = list(normcounts = neftel.smt.norm), colData =  celltype.df) -->
<!-- logcounts(neftel.smt.sce) <- log2(normcounts(neftel.smt.sce) + 1) -->

<!-- rowData(neftel.smt.sce)$feature_symbol <- rownames(neftel.smt.sce) -->

<!-- neftel.smt.sce <- neftel.smt.sce[!duplicated(rownames(neftel.smt.sce)), ] -->
<!-- ``` -->


<!-- ```{r} -->
<!-- neftel.smt.sce <- selectFeatures(neftel.smt.sce, n_features = 500,suppress_plot = FALSE) -->

<!-- #table(rowData(neftel.smt.sce)$scmap_features) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- neftel.smt.sce <- indexCluster(neftel.smt.sce, cluster_col = celltype) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- heatmap(as.matrix(metadata(neftel.smt.sce)$scmap_cluster_index)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- head(metadata(neftel.smt.sce)$scmap_cluster_index) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- gc() -->
<!-- gbm <- readRDS("./../output/seurat_gbm_qc") -->
<!-- gbm.list <- SplitObject(gbm, split.by = "split") -->

<!-- gbm.list[["run2_radiated_E31N"]] <- merge(gbm.list[["run2_radiated_E31N"]], y=gbm.list[["run1_radiated_E31N"]]) -->
<!-- gbm.list[["run2_control_E31N"]] <- merge(gbm.list[["run2_control_E31N"]], y=gbm.list[["run1_control_E31N"]]) -->
<!-- gbm.list[["run2_radiated_E26N"]] <- merge(gbm.list[["run2_radiated_E26N"]], y=gbm.list[["run1_radiated_E26N"]]) -->
<!-- gbm.list[["run2_radiated_E24N"]] <- merge(gbm.list[["run2_radiated_E24N"]], y=gbm.list[["run1_radiated_E24N"]]) -->
<!-- gbm.list[c("run1_radiated_E24N","run1_radiated_E26N","run1_control_E31N","run1_radiated_E31N")] <- NULL -->
<!-- rm(gbm) -->
<!-- gc() -->

<!-- gbm.list$run1_control_E55N@meta.data -->
<!-- nrow -->

<!-- ``` -->

<!-- ```{r} -->
<!-- x.list <- lapply(X = gbm.list,  FUN = function(x)  { -->
<!--   x <- nrow(x@meta.data) -->
<!--   return(x) -->
<!-- }) -->
<!-- Reduce('+',x.list) -->
<!-- x.list -->
<!-- ``` -->
<!-- ```{r} -->
<!-- str(gbm.list.res) -->
<!-- str(gbm.list.res) -->
<!-- ``` -->


<!-- ```{r} -->

<!-- #test <- NormalizeData(gbm.list[[4]],verbose= FALSE,normalization.method = "RC") -->
<!-- test <- gbm.list[[5]] -->
<!-- test <- NormalizeData(test,verbose= FALSE,normalization.method = "RC") -->
<!-- test.matrix <- test@assays$RNA@data -->
<!-- celltype.df.test <- rownames(test@meta.data) -->
<!-- celltype.df.test -->
<!-- sce <- SingleCellExperiment(assays = list(normcounts = as.matrix(test.matrix)), colData =  celltype.df.test) -->
<!-- logcounts(sce) <- log2(normcounts(sce) + 1) -->
<!-- # use gene names as feature symbols -->
<!-- rowData(sce)$feature_symbol <- rownames(sce) -->
<!-- # remove features with duplicated names -->
<!-- sce <- sce[!duplicated(rownames(sce)), ] -->


<!-- scmapCluster_results_test <- scmapCluster(threshold = 0, -->
<!--   projection = sce,  -->
<!--   index_list = list( -->
<!--     neftel.smt.norm = metadata(neftel.smt.sce)$scmap_cluster_index -->
<!--   ) -->
<!-- ) -->

<!-- scmapCluster_results_test -->
<!-- plot( -->
<!--   getSankey( -->
<!--     neftel.smt.sce@colData[,celltype],  -->
<!--     scmapCluster_results_test$scmap_cluster_labs[,'neftel.smt.norm'], -->
<!--     plot_height = 400 -->
<!--   ) -->
<!-- ) -->

<!-- ``` -->


<!-- ```{r} -->
<!-- library(parallel) -->
<!-- #n.cores <- parallel::detectCores() - 1 -->
<!-- n.cores <- 4 -->
<!-- rm(gbm.list.res) -->
<!-- system.time(gbm.list.res <- mclapply(X = gbm.list, mc.cores = n.cores, FUN = function(x)  { -->
<!-- #system.time(gbm.list.res <- lapply(X = gbm.list,  FUN = function(x)  { -->
<!--   name <- rownames(x@meta.data) -->
<!--   x <- NormalizeData(x,verbose= FALSE,normalization.method = "RC") -->
<!--   x <- x@assays$RNA@data -->
<!--   x <- SingleCellExperiment(assays = list(normcounts = as.matrix(x))) -->
<!--   logcounts(x) <- log2(normcounts(x) + 1) -->
<!--   # use gene names as feature symbols -->
<!--   rowData(x)$feature_symbol <- rownames(x) -->
<!--   # remove features with duplicated names -->
<!--   x <- x[!duplicated(rownames(x)), ] -->


<!--   x <- scmapCluster(threshold = 0, -->
<!--     projection = x,  -->
<!--     index_list = list( -->
<!--       neftel.smt.norm = metadata(neftel.smt.sce)$scmap_cluster_index -->
<!--     ) -->
<!--   ) -->
<!--   return(list(name,x$scmap_cluster_labs)) -->

<!-- })) -->

<!-- ``` -->
<!-- ```{r} -->
<!-- cell.id <- lapply(gbm.list.res, "[[", 1) -->
<!-- gbm.list.res <- lapply(gbm.list.res, "[[", 2) -->

<!-- cell.id <- as.character(unlist(cell.id)) -->
<!-- cell.id -->
<!-- gbm.list.res <- as.character(unlist(gbm.list.res)) -->
<!-- ``` -->


<!-- ```{r} -->
<!-- prediction <- data.frame(cell_id = cell.id,scmap_cluster = gbm.list.res) -->
<!-- prediction -->
<!-- ``` -->

<!-- ```{r} -->
<!-- rownames(prediction) <- prediction$cell_id -->
<!-- prediction <- prediction["scmap_cluster"] -->

<!-- prediction -->
<!-- ``` -->

<!-- ```{r} -->
<!-- write.csv(prediction,paste0("./../output/scmap_cluster_",object,"_",merge,".csv"),row.names = TRUE) -->
<!-- ``` -->


<!-- ```{r} -->
<!-- set.seed(1) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- neftel.smt.sce <- indexCell(neftel.smt.sce) -->

<!-- names(metadata(neftel.smt.sce)$scmap_cell_index) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- library(parallel) -->
<!-- #n.cores <- parallel::detectCores() - 1 -->
<!-- n.cores <- 1 -->
<!-- rm(gbm.list.res) -->
<!-- gbm.list -->
<!-- #system.time(gbm.list.res <- mclapply(X = gbm.list, mc.cores = n.cores, FUN = function(x)  { -->
<!-- system.time(gbm.list.res <- lapply(X = gbm.list,  FUN = function(x)  { -->
<!--   name <- rownames(x@meta.data) -->
<!--   x <- NormalizeData(x,verbose= FALSE,normalization.method = "RC") -->
<!--   x <- x@assays$RNA@data -->
<!--   x <- SingleCellExperiment(assays = list(normcounts = as.matrix(x))) -->
<!--   logcounts(x) <- log2(normcounts(x) + 1) -->
<!--   # use gene names as feature symbols -->
<!--   rowData(x)$feature_symbol <- rownames(x) -->
<!--   # remove features with duplicated names -->
<!--   x <- x[!duplicated(rownames(x)), ] -->


<!--   x <- scmapCell( -->
<!--     projection = x,  -->
<!--     index_list = list( -->
<!--       neftel.smt.norm = metadata(neftel.smt.sce)$scmap_cell_index -->
<!--     ) -->
<!--   ) -->
<!--   x <- scmapCell2Cluster(x, list(as.character(neftel.smt.sce@colData[,celltype])),threshold = 0) -->
<!--   return(list(name,x$combined_labs)) -->

<!-- })) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- cell.id <- lapply(gbm.list.res, "[[", 1) -->
<!-- gbm.list.res <- lapply(gbm.list.res, "[[", 2) -->

<!-- cell.id <- as.character(unlist(cell.id)) -->
<!-- cell.id -->
<!-- gbm.list.res <- as.character(unlist(gbm.list.res)) -->
<!-- ``` -->


<!-- ```{r} -->
<!-- prediction <- data.frame(cell_id = cell.id,scmap_cell = gbm.list.res) -->
<!-- prediction -->
<!-- ``` -->

<!-- ```{r} -->
<!-- rownames(prediction) <- prediction$cell_id -->
<!-- prediction <- prediction["scmap_cell"] -->

<!-- prediction -->
<!-- ``` -->

<!-- ```{r} -->
<!-- write.csv(prediction,paste0("./../output/scmap_cell_",object,"_",merge,".csv"),row.names = TRUE) -->
<!-- ``` -->


#scibet
<!-- ```{r} -->
<!-- library(scibet) -->
<!-- library(SeuratDisk) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- reference <- readRDS("./../output/smrt_mal") -->
<!-- reference.exp <- reference@assays$norm@data -->
<!-- reference.exp <- t(as.matrix(reference.exp)) -->
<!-- reference.exp <- as.data.frame(reference.exp) -->


<!-- reference@meta.data[,celltype] -->
<!-- #Check whether after transpose the cell is in the same position -->
<!-- table(rownames(reference@meta.data) == rownames(reference.exp)) -->

<!-- #Add label to last column (as instructed by scibet http://scibet.cancer-pku.cn/document.html) -->
<!-- reference.exp$label <-  reference@meta.data[,celltype] -->
<!-- ``` -->

<!-- ```{r} -->
<!-- gbm <- readRDS("./../output/seurat_gbm_qc") -->
<!-- gbm.list <- SplitObject(gbm, split.by = "split") -->

<!-- gbm.list[["run2_radiated_E31N"]] <- merge(gbm.list[["run2_radiated_E31N"]], y=gbm.list[["run1_radiated_E31N"]]) -->
<!-- gbm.list[["run2_control_E31N"]] <- merge(gbm.list[["run2_control_E31N"]], y=gbm.list[["run1_control_E31N"]]) -->
<!-- gbm.list[["run2_radiated_E26N"]] <- merge(gbm.list[["run2_radiated_E26N"]], y=gbm.list[["run1_radiated_E26N"]]) -->
<!-- gbm.list[["run2_radiated_E24N"]] <- merge(gbm.list[["run2_radiated_E24N"]], y=gbm.list[["run1_radiated_E24N"]]) -->
<!-- gbm.list[c("run1_radiated_E24N","run1_radiated_E26N","run1_control_E31N","run1_radiated_E31N")] <- NULL -->
<!-- ``` -->


<!-- ```{r} -->
<!-- library(parallel) -->
<!-- n.cores <- parallel::detectCores() - 1 -->

<!-- system.time(gbm.list.res <- mclapply(X = gbm.list, mc.cores = n.cores, FUN = function(x)  { -->
<!--   x <- NormalizeData(x,verbose= FALSE,normalization.method = "RC") -->
<!--   x <- x@assays$RNA@data -->
<!--   x <- t(as.matrix(x)) -->
<!--   x <- as.data.frame(x) -->

<!--   pred <- SciBet(reference.exp,x) -->
<!--   return(list(rownames(x),pred)) -->
<!-- })) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- cell.id <- lapply(gbm.list.res, "[[", 1) -->
<!-- gbm.list.res <- lapply(gbm.list.res, "[[", 2) -->

<!-- cell.id <- as.character(unlist(cell.id)) -->


<!-- gbm.list.res<- as.character(unlist(gbm.list.res)) -->
<!-- prediction <- data.frame(cell_id = cell.id,scibet = gbm.list.res) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- rownames(prediction) <- prediction$cell_id -->
<!-- prediction <- prediction["scibet"] -->
<!-- ``` -->
<!-- ```{r} -->
<!-- table(prediction$scibet) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- write.csv(prediction,paste0("./../output/scibet_",object,"_",merge,".csv"),row.names = TRUE) -->
<!-- ``` -->

#scPred
<!-- ```{r} -->
<!-- library(scPred) -->
<!-- reference <- readRDS("./../output/smrt_mal") -->
<!-- ``` -->

<!-- ```{r} -->
<!-- reference <- FindVariableFeatures(reference,verbose = FALSE) -->
<!-- reference <- ScaleData(reference,verbose = FALSE) -->
<!-- reference <- RunPCA(reference, verbose = FALSE) -->
<!-- ``` -->




<!-- ```{r} -->
<!-- reference <- getFeatureSpace(reference, celltype,correction = "fdr", sig = 1, reduction = "pca") -->
<!-- reference <- trainModel(reference) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- get_probabilities(reference) %>% head() -->
<!-- ``` -->

<!-- ```{r} -->
<!-- get_scpred(reference) -->
<!-- ``` -->


<!-- ```{r} -->
<!-- plot_probabilities(reference) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- reference <- trainModel(reference, model = "mda") -->
<!-- get_scpred(reference) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- reference <- trainModel(reference, model = "glm") -->
<!-- get_scpred(reference) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- gbm <- readRDS("./../output/seurat_gbm_qc") -->
<!-- gbm.list <- SplitObject(gbm, split.by = "split") -->

<!-- gbm.list[["run2_radiated_E31N"]] <- merge(gbm.list[["run2_radiated_E31N"]], y=gbm.list[["run1_radiated_E31N"]]) -->
<!-- gbm.list[["run2_control_E31N"]] <- merge(gbm.list[["run2_control_E31N"]], y=gbm.list[["run1_control_E31N"]]) -->
<!-- gbm.list[["run2_radiated_E26N"]] <- merge(gbm.list[["run2_radiated_E26N"]], y=gbm.list[["run1_radiated_E26N"]]) -->
<!-- gbm.list[["run2_radiated_E24N"]] <- merge(gbm.list[["run2_radiated_E24N"]], y=gbm.list[["run1_radiated_E24N"]]) -->
<!-- gbm.list[c("run1_radiated_E24N","run1_radiated_E26N","run1_control_E31N","run1_radiated_E31N")] <- NULL -->
<!-- ``` -->

<!-- ```{r} -->
<!-- library(parallel) -->

<!-- n.cores <- parallel::detectCores() - 1 -->
<!-- system.time(gbm.list.res <- mclapply(X = gbm.list, mc.cores = n.cores, FUN = function(x)  { -->
<!--   x <- NormalizeData(x,verbose= FALSE) -->
<!--   x <- FindVariableFeatures(x, verbose= FALSE) -->
<!--   x <- ScaleData(x,verbose = FALSE) -->
<!--   x <- RunPCA(x, verbose = FALSE) -->
<!--   x <- FindNeighbors(x, reduction = "pca", dims = 1:20, verbose = FALSE) -->
<!--   x <- FindClusters(x, resolution = 1, verbose = FALSE) -->
<!--   x <- scPredict(x, reference) -->
<!-- })) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- each.meta.all <- data.frame() -->
<!-- for (i in 1:length(gbm.list.res)) { -->
<!--   each.meta <- gbm.list.res[[i]]@meta.data -->
<!--   each.meta <- each.meta[tail(names(each.meta),9)] -->
<!--   each.meta <- each.meta %>% relocate(c("scpred_no_rejection","scpred_prediction","scpred_max"),.before = 1) -->
<!--   each.meta.all <- rbind(each.meta.all,each.meta) -->
<!-- } -->
<!-- each.meta.all <- rownames_to_column(each.meta.all) -->
<!-- colnames(each.meta.all)[1] <- "cell_id" -->

<!-- each.meta.all -->
<!-- ``` -->

<!-- ```{r} -->
<!-- table(each.meta.all$scpred_no_rejection) -->
<!-- table(each.meta.all$scpred_prediction) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- write.csv(each.meta.all,paste0("./../output/scpred_",object,"_",merge,".csv"),row.names = FALSE) -->
<!-- ``` -->








#SingleCellNet
<!-- ```{r} -->
<!-- library(singleCellNet) -->

<!-- neftel.smt.scn <- readRDS("./../output/smrt_mal") -->
<!-- neftel.smt.scn <- extractSeurat(neftel.smt.scn, exp_slot_name = "data") -->
<!-- stTM = neftel.smt.scn$sampTab -->
<!-- expTMraw = neftel.smt.scn$expDat -->

<!-- stTM<-droplevels(stTM) -->

<!-- gbm.scn <- readRDS("./../output/seurat_gbm_qc") -->
<!-- gbm.scn <- extractSeurat(gbm.scn, exp_slot_name = "data") -->
<!-- stQuery = gbm.scn$sampTab -->
<!-- expQuery = gbm.scn$expDat -->

<!-- rm(neftel.smt.scn,gbm.scn) -->
<!-- gc() -->

<!-- commonGenes<-intersect(rownames(expTMraw), rownames(expQuery)) -->
<!-- expTMraw <- expTMraw[commonGenes, ] -->
<!-- expQuery <- expQuery[commonGenes, ] -->
<!-- ``` -->


<!-- ```{r} -->
<!-- # So compare accuracy between celltype and celltype_merge it seem that celltype_merge perform better so we will use that instead -->
<!-- ``` -->

<!-- ```{r} -->
<!-- #Train -->
<!-- set.seed(100) -->
<!-- stList<-splitCommon(sampTab = stTM, ncells = as.integer(0.8*(min(table(stTM$celltype)))), dLevel = celltype) -->

<!-- stTrain<-stList[[1]] -->
<!-- expTrain <- expTMraw[,rownames(stTrain)] -->

<!-- system.time(class_info<-scn_train(stTrain = stTrain, expTrain = expTrain, nTopGenes = 10, nRand = 70, nTrees = 1000, nTopGenePairs = 25, dLevel = celltype, colName_samp = "NAME")) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- #Test/validate -->
<!-- set.seed(2) -->
<!-- stTestList = splitCommon(sampTab=stList[[2]], as.integer(0.2*(min(table(stTM$celltype_merge)))), dLevel="celltype_merge")  -->
<!-- stTest = stTestList[[1]] -->
<!-- expTest = expTMraw[commonGenes,rownames(stTest)] -->

<!-- classRes_val_all = scn_predict(cnProc=class_info[['cnProc']], expDat=expTest, nrand = 50) -->

<!-- tm_heldoutassessment = assess_comm(ct_scores = classRes_val_all, stTrain = stTrain, stQuery = stTest, dLevelSID = "NAME", classTrain = "celltype_merge", classQuery = "celltype_merge", nRand = 50) -->

<!-- plot_PRs(tm_heldoutassessment) -->

<!-- plot_metrics(tm_heldoutassessment) -->

<!-- nrand = 50 -->
<!-- sla = as.vector(stTest$celltype_merge) -->
<!-- names(sla) = as.vector(stTest$NAME) -->
<!-- slaRand = rep("rand", nrand)  -->
<!-- names(slaRand) = paste("rand_", 1:nrand, sep='') -->
<!-- sla = append(sla, slaRand) #include in the random cells profile created -->
<!-- sc_hmClass(classMat = classRes_val_all,grps = sla, max=300, isBig=TRUE) -->

<!-- plot_attr(classRes=classRes_val_all, sampTab=stTest, nrand=nrand, dLevel="celltype_merge", sid="NAME") -->
<!-- ``` -->

<!-- ```{r} -->
<!-- #Predict on our gbm dataset -->

<!-- stQuery.list <- split(stQuery, f = stQuery$split) -->

<!-- stQuery.all <- data.frame() -->

<!-- for (i in 1:length(stQuery.list)) { -->
<!-- stQuery.each <- stQuery.list[[i]] -->
<!-- expQuery.each <- expQuery[, colnames(expQuery) %in% rownames(stQuery.each)] -->

<!-- gbm.pre <- scn_predict(class_info[['cnProc']], expQuery.each, nrand = 0) -->
<!-- stQuery.each <- assign_cate(classRes = gbm.pre, sampTab = stQuery.each, cThresh = 0.5) -->

<!-- stQuery.all <- rbind(stQuery.all,stQuery.each) -->
<!-- } -->
<!-- ``` -->



<!-- ```{r} -->
<!-- colnames(stQuery.all)[which(colnames(stQuery.all) == "category")] <-  "SingleCellNet" -->
<!-- annotation <- stQuery.all["SingleCellNet"] -->

<!-- annotation -->
<!-- ``` -->

<!-- ```{r} -->
<!-- #save result -->
<!-- write.csv(annotation,paste0("./../output/singleCellNet_",object,"_",merge,".csv"),row.names = TRUE) -->
<!-- ``` -->

#scClasify

<!-- ```{r} -->
<!-- library("scClassify") -->
<!-- ``` -->
<!-- ```{r} -->
<!-- neftel.smt <- readRDS("./../output/smrt_mal"); neftel.smt <- subset(neftel.smt,idents = chosen_celltypes); -->
<!-- exprsMat_neftel <- neftel.smt@assays$RNA@data -->

<!-- neftel_celltype_merge <- neftel.smt$celltype_merge -->
<!-- ``` -->
<!-- ```{r} -->
<!-- gbm <- readRDS("./../output/seurat_gbm_qc") -->
<!-- gbm.list <- SplitObject(gbm, split.by = "split") -->

<!-- gbm.list[["run2_radiated_E31N"]] <- merge(gbm.list[["run2_radiated_E31N"]], y=gbm.list[["run1_radiated_E31N"]]) -->
<!-- gbm.list[["run2_control_E31N"]] <- merge(gbm.list[["run2_control_E31N"]], y=gbm.list[["run1_control_E31N"]]) -->
<!-- gbm.list[["run2_radiated_E26N"]] <- merge(gbm.list[["run2_radiated_E26N"]], y=gbm.list[["run1_radiated_E26N"]]) -->
<!-- gbm.list[["run2_radiated_E24N"]] <- merge(gbm.list[["run2_radiated_E24N"]], y=gbm.list[["run1_radiated_E24N"]]) -->
<!-- gbm.list[c("run1_radiated_E24N","run1_radiated_E26N","run1_control_E31N","run1_radiated_E31N")] <- NULL -->

<!-- gbm.list <- lapply(X = gbm.list, FUN = function(x)  { -->
<!--   x <- NormalizeData(x,verbose = FALSE) -->
<!-- }) -->

<!-- ``` -->

<!-- ```{r} -->
<!-- res.df <- data.frame() -->
<!-- #for (i in 1:length(gbm.list)) { -->
<!-- for (i in 4:5) { -->
<!--   gbm.each <- gbm.list[[i]] -->
<!--   exprsMat_gbm <- gbm.each@assays$RNA@data -->
<!--   scClassify_res <- scClassify(exprsMat_train = exprsMat_neftel, -->
<!--                              cellTypes_train = neftel_celltype_merge, -->
<!--                              exprsMat_test = list(gbm = exprsMat_gbm), -->
<!--                              tree = "HOPACH", -->
<!--                              algorithm = "WKNN", -->
<!--                              selectFeatures = c("limma"), -->
<!--                              similarity = c("pearson"), -->
<!--                              returnList = FALSE, -->
<!--                              verbose = TRUE) -->
<!--   # res.df.test <- append(res.df.test,list(pred.grun)) -->
<!--   res.df <- rbind(res.df,as.data.frame(scClassify_res$testRes$gbm$pearson_WKNN_limma$predRes)) -->
<!-- } -->
<!-- ``` -->


<!-- ```{r} -->
<!-- colnames(res.df) <- paste0("scClasify_","pearson_WKNN_limma") -->
<!-- res.df <- rownames_to_column(res.df) -->
<!-- colnames(res.df)[1] <- "cell_id" -->
<!-- head(res.df) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- write.csv(res.df,paste0("./../output/scClassify_",object,"_",merge,".csv"),row.names = FALSE) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- plotCellTypeTree(cellTypeTree(scClassify_res$trainRes)) -->
<!-- ``` -->
